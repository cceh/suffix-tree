<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Ukkonen Builder &mdash; suffix-tree 0.1.0 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/favicon-cceh-blue.png"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script>window.MathJax = {"tex": {"macros": {"bs": ["\\boldsymbol"], "suf": ["\\mathrm{\\bf suf}_{\\mkern 1mu\\bs{#1}}", 1], "head": ["\\mathrm{\\bf head}_{\\mkern 1mu\\bs{#1}}", 1], "tail": ["\\mathrm{\\bf tail}_{\\mkern 1mu\\bs{#1}}", 1]}}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Naive Builder" href="naive.html" />
    <link rel="prev" title="McCreight Builder" href="mccreight.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> suffix-tree
            <img src="../_static/logo-cceh-white.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tree.html">Tree</a></li>
<li class="toctree-l1"><a class="reference internal" href="../node.html">Node</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lca.html">LCA Mixin</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../builders.html">Builders</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="mccreight.html">McCreight Builder</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Ukkonen Builder</a></li>
<li class="toctree-l2"><a class="reference internal" href="naive.html">Naive Builder</a></li>
<li class="toctree-l2"><a class="reference internal" href="builder.html">Base Class for Builders</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../util.html">Utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../performance.html">Performance</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../performance.html#time-complexity">Time Complexity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance.html#python-3-10-7">Python 3.10.7</a></li>
<li class="toctree-l2"><a class="reference internal" href="../performance.html#pypy-7-3-9">PyPy 7.3.9</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../references.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">suffix-tree</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../builders.html">Builders</a> &raquo;</li>
      <li>Ukkonen Builder</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/builder/ukkonen.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="ukkonen-builder">
<h1>Ukkonen Builder<a class="headerlink" href="#ukkonen-builder" title="Permalink to this headline"></a></h1>
<p>Ukkonen’s algorithm is very similar to McCreight’s.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 27%" />
<col style="width: 41%" />
<col style="width: 32%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>McCreight1976</p></th>
<th class="head"><p>Ukkonen1995</p></th>
<th class="head"><p>English</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>step</p></td>
<td><p>phase</p></td>
<td><p>round</p></td>
</tr>
<tr class="row-odd"><td><p>locus</p></td>
<td><p>implicit state</p></td>
<td><p>node + substring</p></td>
</tr>
<tr class="row-even"><td><p>locus node</p></td>
<td><p>explicit state</p></td>
<td><p>node</p></td>
</tr>
<tr class="row-odd"><td><p></p></td>
<td><p>branching state</p></td>
<td><p>internal node</p></td>
</tr>
<tr class="row-even"><td><p></p></td>
<td><p>final state</p></td>
<td><p>leaf</p></td>
</tr>
<tr class="row-odd"><td><p>arc</p></td>
<td><p>transition function</p></td>
<td><p>edge</p></td>
</tr>
<tr class="row-even"><td><p>suffix link</p></td>
<td><p>suffix function</p></td>
<td><p>suffix pointer</p></td>
</tr>
<tr class="row-odd"><td><p>head</p></td>
<td><p>active point</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>contracted locus</p></td>
<td><p>canonical representation</p></td>
<td><p>parent node</p></td>
</tr>
<tr class="row-odd"><td><p>scan</p></td>
<td></td>
<td><p>search</p></td>
</tr>
<tr class="row-even"><td><p>rescan</p></td>
<td><p>canonize</p></td>
<td><p>fast-forward search</p></td>
</tr>
</tbody>
</table>
<p>The differences are: In round <span class="math notranslate nohighlight">\(i\)</span> Ukkonen inserts character <span class="math notranslate nohighlight">\(t_i\)</span> into the tree while
McCreight inserts the whole suffix <span class="math notranslate nohighlight">\(t_i\dots t_n\)</span>.  Ukkonen’s algorithm  does not need
to know the characters following <span class="math notranslate nohighlight">\(t_i\)</span>. It can build a tree from a Python generator and
be ready in constant time after the last character was generated.</p>
<p>McCreight’s algorithm is easier to understand.  McCreight inserts one leaf and at most
one internal node per round.  It is not clear beforehand how many leafs and internal
nodes a round in Ukkonen’s will insert: in Fig. 2 of Ukkonen’s paper, the last round
creates 2 internal nodes and 3 new leaves, while both preceding rounds created nothing.</p>
<p>Some annotations to Ukkonen’s paper follow:</p>
<p>Ukkonen identifies subsequences by two indices: <span class="math notranslate nohighlight">\(k\)</span> and <span class="math notranslate nohighlight">\(p\)</span>.  In a generalized suffix
tree these are not sufficient to uniquely identify a subsequence, we also need to know
to which sequence <span class="math notranslate nohighlight">\(k\)</span> and <span class="math notranslate nohighlight">\(p\)</span> are referring.  So instead of using the parameter pair
<span class="math notranslate nohighlight">\((k,p)\)</span> we use three parameters: <span class="math notranslate nohighlight">\((S,k,p)\)</span>. We also prefer to name them: <code class="docutils literal notranslate"><span class="pre">S,</span> <span class="pre">start,</span>
<span class="pre">end</span></code>.</p>
<p>We also have two problems with indices:  The first is that Python indices start with 0
while Ukkonen’s start with 1.  The second is that Python indices point to one beyond the
end while Ukkonen’s point to the end.  In conclusion: Ukkonen’s <span class="math notranslate nohighlight">\(1..2\)</span> becomes Python’s
<code class="docutils literal notranslate"><span class="pre">[0:2]</span></code>.</p>
<p>Ukkonen treats the <em>suffix trie</em> as an automaton and thus uses <em>transition function</em> to
describe what a mere mortal would call an <em>edge</em>, and <em>explicit state</em> <span class="math notranslate nohighlight">\(s\)</span> to describe
what the rest of us would call a <em>node.</em>  Edges in a trie are labeled by one character
only.  A <em>branching state</em> is an internal node, a <em>final state</em> is a leaf node.  Every
node in the trie represents a substring and every leaf node represents a suffix.  The
converse is true.  The node representing the string <span class="math notranslate nohighlight">\(abc\)</span> is called <span class="math notranslate nohighlight">\(\overline{abc}\)</span>.</p>
<p>A <em>suffix tree</em> is a compressed suffix trie without those internal nodes that have only
one child.  Edges in a tree are labeled by more than one character.  As a consequence
those states in the trie that had their nodes removed become <em>implicit states</em> in the
tree.  Those that still retain their nodes are <em>explicit states</em>.  Explicit substrings
always end on a node, implicit ones end in the middle of an edge (but can be made
explict by splitting the edge).</p>
<p>States are represented by the triple: <span class="math notranslate nohighlight">\((s,(k,p))\)</span>, which is a node and a substring
going out of the node.  There may be more than one such representation.  Remember that
we use <code class="docutils literal notranslate"><span class="pre">node,</span> <span class="pre">S,</span> <span class="pre">start,</span> <span class="pre">end</span></code> instead.</p>
<p>The <em>canonical representation</em> of a state is: the state itself and an empty substring if
explicit, the nearest node above the state and the shortest possible substring if
implicit.</p>
<p>The <em>transition function</em> <span class="math notranslate nohighlight">\(g'(s,(k,p)) = r\)</span> starts at node <span class="math notranslate nohighlight">\(s\)</span> and ends at the state
<span class="math notranslate nohighlight">\(r\)</span>, which may be a node or an implicit state (in the middle of an edge).</p>
<p>The <em>suffix function</em> <span class="math notranslate nohighlight">\(f(\bar x) = \bar y\)</span> is a link present at each internal node, that
points to another node that encodes the same suffix minus the first symbol.  Following
suffix links you get from: cacao -&gt; acao -&gt; cao -&gt; ao -&gt; a -&gt; root -&gt; aux.</p>
<p>An <em>open transition</em> is any edge going into a leaf.  A leaf’s <code class="docutils literal notranslate"><span class="pre">end</span></code> grows
automatically whenever a new symbol is added to the tree.</p>
<p>The <em>boundary path</em> of a trie is the chain of suffix links starting at the deepest state
and ending at aux. In a tree the states on the boundary path may be implicit.  To follow
an implicit boundary path we use substep A and substep B from McCreight’s algorithm.</p>
<p>The <em>active point</em> and <em>end point</em> are states on the boundary path.  Active point and
end point may be the same point.  The active point is the first state on the boundary
path that is not a leaf, the end point ist the first state that already has the
transition we trying to are add, and if we follow that transition we reach the next
active point.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../references.html#ukkonen1995" id="id1"><span>[Ukkonen1995]</span></a></p>
<p>Ukkonen’s suffix tree algorithm in plain English
<a class="reference external" href="https://stackoverflow.com/questions/9452701/">https://stackoverflow.com/questions/9452701/</a></p>
</div>
<span class="target" id="module-suffix_tree.ukkonen"></span><p>A tree builder that uses Ukkonen’s Algorithm.</p>
<p>This module implements Ukkonen’s algorithm to build a suffix tree in linear time,
adapted to generalized suffix trees.</p>
<dl class="py class">
<dt class="sig sig-object py" id="suffix_tree.ukkonen.Builder">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Builder</span></span><a class="headerlink" href="#suffix_tree.ukkonen.Builder" title="Permalink to this definition"></a></dt>
<dd><p>Builds the suffix-tree using Ukkonen’s Algorithm.</p>
<dl class="py method">
<dt class="sig sig-object py" id="suffix_tree.ukkonen.Builder.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#suffix_tree.ukkonen.Builder.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="suffix_tree.ukkonen.Builder.transition">
<span class="sig-name descname"><span class="pre">transition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="../node.html#suffix_tree.node.Internal" title="suffix_tree.node.Internal"><span class="pre">suffix_tree.node.Internal</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../node.html#suffix_tree.node.Node" title="suffix_tree.node.Node"><span class="pre">suffix_tree.node.Node</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">collections.abc.Hashable</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#suffix_tree.ukkonen.Builder.transition" title="Permalink to this definition"></a></dt>
<dd><p>Follow the <span class="math notranslate nohighlight">\(s,S,k\)</span> transition.</p>
<p>Let <span class="math notranslate nohighlight">\(g'(s,(k',p')) = s'\)</span> be the <span class="math notranslate nohighlight">\(t_k\)</span>-transition from <span class="math notranslate nohighlight">\(s\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>s</strong> (<a class="reference internal" href="../node.html#suffix_tree.node.Internal" title="suffix_tree.node.Internal"><em>node.Internal</em></a>) – the state <span class="math notranslate nohighlight">\(s\)</span></p></li>
<li><p><strong>k</strong> (<em>int</em>) – <span class="math notranslate nohighlight">\(k\)</span></p></li>
</ul>
</dd>
<dt class="field-even">Return tuple</dt>
<dd class="field-even"><p><span class="math notranslate nohighlight">\(s,S,k,p\)</span></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="suffix_tree.ukkonen.Builder.test_and_split">
<span class="sig-name descname"><span class="pre">test_and_split</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="../node.html#suffix_tree.node.Internal" title="suffix_tree.node.Internal"><span class="pre">suffix_tree.node.Internal</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">start</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">collections.abc.Hashable</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">bool</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="../node.html#suffix_tree.node.Internal" title="suffix_tree.node.Internal"><span class="pre">suffix_tree.node.Internal</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#suffix_tree.ukkonen.Builder.test_and_split" title="Permalink to this definition"></a></dt>
<dd><p>Test if endpoint and eventually split a transition.</p>
<p>Return True, if s is the end point.</p>
<p>“Tests whether or not a state with canonical reference pair <span class="math notranslate nohighlight">\((s,(k,p))\)</span> is the
end point, that is, a state that in <span class="math notranslate nohighlight">\(STrie(T^{i-1})\)</span> would have a
<span class="math notranslate nohighlight">\(t_i\)</span>-transition.  Symbol <span class="math notranslate nohighlight">\(t_i\)</span> is given as input parameter <span class="math notranslate nohighlight">\(t\)</span>.  The test
result is returned as the first output parameter.  If <span class="math notranslate nohighlight">\((s,(k,p))\)</span> is not the end
point, then state <span class="math notranslate nohighlight">\((s,(k,p))\)</span> is made explicit (if not already so) by splitting
a transition.  The explicit state is returned as the second output parameter.”
– <a class="reference internal" href="../references.html#ukkonen1995" id="id2"><span>[Ukkonen1995]</span></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="suffix_tree.ukkonen.Builder.canonize">
<span class="sig-name descname"><span class="pre">canonize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="../node.html#suffix_tree.node.Internal" title="suffix_tree.node.Internal"><span class="pre">suffix_tree.node.Internal</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">start</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../node.html#suffix_tree.node.Internal" title="suffix_tree.node.Internal"><span class="pre">suffix_tree.node.Internal</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#suffix_tree.ukkonen.Builder.canonize" title="Permalink to this definition"></a></dt>
<dd><p>Canonize a reference pair.</p>
<p>This has the same function as substep b in McCreight’s algorithm.</p>
<p>“Given a reference pair <span class="math notranslate nohighlight">\((s,(k,p))\)</span> for some state <span class="math notranslate nohighlight">\(r\)</span>, it finds and returns
state <span class="math notranslate nohighlight">\(s'\)</span> and left link <span class="math notranslate nohighlight">\(k'\)</span> such that <span class="math notranslate nohighlight">\((s',(k',p))\)</span> is the canonical reference
pair for <span class="math notranslate nohighlight">\(r\)</span>.  State <span class="math notranslate nohighlight">\(s'\)</span> is the closest explicit ancestor of <span class="math notranslate nohighlight">\(r\)</span> (or <span class="math notranslate nohighlight">\(r\)</span> itself
if <span class="math notranslate nohighlight">\(r\)</span> is explicit).  Therefore the string that leads from <span class="math notranslate nohighlight">\(s'\)</span> to <span class="math notranslate nohighlight">\(r\)</span> must be a
suffix of the string <span class="math notranslate nohighlight">\(t_k\dots t_p\)</span> that leads from <span class="math notranslate nohighlight">\(s\)</span> to <span class="math notranslate nohighlight">\(r\)</span>.  Hence the right
link <span class="math notranslate nohighlight">\(p\)</span> does not change but the left link <span class="math notranslate nohighlight">\(k\)</span> can become <span class="math notranslate nohighlight">\(k', k' \geq k\)</span>.”
– <a class="reference internal" href="../references.html#ukkonen1995" id="id3"><span>[Ukkonen1995]</span></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="suffix_tree.ukkonen.Builder.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="../node.html#suffix_tree.node.Internal" title="suffix_tree.node.Internal"><span class="pre">suffix_tree.node.Internal</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">start</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../node.html#suffix_tree.node.Internal" title="suffix_tree.node.Internal"><span class="pre">suffix_tree.node.Internal</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#suffix_tree.ukkonen.Builder.update" title="Permalink to this definition"></a></dt>
<dd><p>Update the tree.</p>
<p>“[…] transforms <span class="math notranslate nohighlight">\(STree(T^{i-1})\)</span> into <span class="math notranslate nohighlight">\(STree(T^i)\)</span> by inserting the
<span class="math notranslate nohighlight">\(t_i\)</span>-transitions in the second group.  The procedure uses procedure canonize
mentioned above, and procedure test-and-split that tests whether or not a given
reference pair refers to the end point.  If it does not then the procedure
creates and returns an explicit state for the reference pair provided that the
pair does not already represent an explicit state.  Procedure update returns a
reference pair for the end point <span class="math notranslate nohighlight">\(s_{j'}\)</span> (actually only the state and the left
pointer of the pair, as the second pointer remains <span class="math notranslate nohighlight">\(i-1\)</span> for all states on the
boundary path).”
– <a class="reference internal" href="../references.html#ukkonen1995" id="id4"><span>[Ukkonen1995]</span></a></p>
<p><span class="math notranslate nohighlight">\(s,(k,i-1)\)</span> is the canonical reference pair for the active
point.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a reference pair for the endpoint <span class="math notranslate nohighlight">\(s_{j\prime}\)</span>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="suffix_tree.ukkonen.Builder.build">
<span class="sig-name descname"><span class="pre">build</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">root</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="../node.html#suffix_tree.node.Internal" title="suffix_tree.node.Internal"><span class="pre">suffix_tree.node.Internal</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">id_</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Iterable</span><span class="p"><span class="pre">[</span></span><span class="pre">collections.abc.Hashable</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#suffix_tree.ukkonen.Builder.build" title="Permalink to this definition"></a></dt>
<dd><p>Add a sequence to the tree.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>root</strong> (<a class="reference internal" href="../node.html#suffix_tree.node.Internal" title="suffix_tree.node.Internal"><em>node.Internal</em></a>) – the root node of the tree</p></li>
<li><p><strong>id</strong> (<em>Id</em>) – the id of the sequence</p></li>
<li><p><strong>S</strong> (<em>IterSymbols</em>) – an iterator over the symbols</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="mccreight.html" class="btn btn-neutral float-left" title="McCreight Builder" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="naive.html" class="btn btn-neutral float-right" title="Naive Builder" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2018-22, Marcello Perathoner.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>